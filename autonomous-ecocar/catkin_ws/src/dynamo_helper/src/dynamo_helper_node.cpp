/*
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

Author: Thomas Passer Jensen (s134234@student.dtu.dk)
*/
#include <ros/ros.h>
#include <vector>
#include <cstdlib>
#include <string>
#include <fstream>
#include <streambuf>

#include <boost/algorithm/string.hpp>

#include <dynamo_msgs/Speak.h>
#include <dynamo_msgs/TeensyRead.h>
#include <dynamo_msgs/TeensyWrite.h>
#include <dynamo_msgs/BrakeStepper.h>

#include "usb_utilities.cpp"
#include "LowPass.h"

#include <std_srvs/SetBool.h>

#define DYNAMO_HELPER_RATE 10 // hz
#define TEENSY_TIMEOUT_TIME 1.0 // seconds

#define BATTERY_VOLTAGE_THRESHOLD 11.0 // voltage at Teensy, it is considerable lower than at battery.

#define BATTERY_VOLTAGE_TIME_CONSTANT 60.0 // seconds
#define BATTERY_VOLTAGE_LOW_MESSAGE_PERIOD 15.0 // seconds

#define RESTART_TEENSY_NODE 1 // 1 if it should start teensy node again if it stops, 0 if not

std::string message;
int sound;

bool gotFirstTeensyMessage = false;

bool lastAutopilot = false;
bool lastParking = false;
bool lastAutopilotActive = false;
bool lastBrake = false;

// Teensy write
dynamo_msgs::TeensyWrite last_teensy_write;
bool burn = false;
bool light = false;
bool blink_left = false;
bool blink_right = false;
bool horn = false;
bool parking = false;
bool autopilotActive = false;

bool autopilot = false;
bool emergencyButton = false;
bool brake = false;

double batteryVoltage = -1;

ros::Time lastTeensyTime;
ros::Time lastTeensyRebootTime;

ros::Time lastLowPowerSpeakTime;

ros::Publisher teensyPub;  //Temporary to activate teensy autopilot ON

LowPass<double> batteryLowpass(BATTERY_VOLTAGE_TIME_CONSTANT, DYNAMO_HELPER_RATE);

std::vector<std::string> node_whitelist = {"/rosout",
                                           "/dynamo_helper_node",
                                           "/teensy_node",
                                           "/rostopic*",
                                           "/rviz*"
                                          };

void speakCallback(const dynamo_msgs::SpeakPtr& msg) {
  ROS_INFO("Speak: [%s]", msg->textMessage.c_str());
  message = msg->textMessage;
  sound = msg->sound;
}

void teensyWriteCallback(const dynamo_msgs::TeensyWritePtr& msg) {
  parking = msg->parking;
  autopilotActive = msg->autopilot_active;

  last_teensy_write = *msg;
}

void teensyReadCallback(const dynamo_msgs::TeensyReadPtr& msg) {
  if (!gotFirstTeensyMessage) {
    ROS_INFO("Received first teensy message. Initialization done.");
    gotFirstTeensyMessage = true;
    batteryLowpass.set(msg->batteryVoltage);
  }
  batteryLowpass.update(msg->batteryVoltage);
  autopilot = (msg->autopilot == 1);
  emergencyButton = (msg->emergencyButton == 1);

  ROS_INFO("BATTERY VOLTAGE %.3f %.3f", msg->batteryVoltage, batteryLowpass.value());

  lastTeensyTime = ros::Time::now();
}

void brakeCallback(const dynamo_msgs::BrakeStepperPtr& msg) {
  brake = (msg->brake_stepper_engaged && msg->brake_power > 0.0);
}

void checkNodeStates() {
  ros::V_string running_nodes;

  bool foundTeensy = false;

  if (ros::master::getNodes(running_nodes)) {
    for (unsigned int i = 0; i < running_nodes.size(); i++) {
      if (running_nodes[i] == "/teensy_node") {
        foundTeensy = true;
        break;
      }
    }

    if (!foundTeensy) {
      ROS_WARN_THROTTLE(1, "Teensy node is not running!");

#if RESTART_TEENSY_NODE
      if ((ros::Time::now() - lastTeensyRebootTime).toSec() > 1.0){
        std::system("gnome-terminal -- rosrun teensy teensy_node");
        lastTeensyRebootTime = ros::Time::now();
      }
#endif
    }

  }
}

void startAutopilot() {
  std::vector<std::string> autonomous_nodes = getAutopilotNodes();

  last_teensy_write.header.stamp = ros::Time::now();
  last_teensy_write.header.frame_id = "dynamo_helper_node";
  last_teensy_write.burn = burn;
  last_teensy_write.light = light;
  last_teensy_write.blink_left = blink_left;
  last_teensy_write.blink_right = blink_right;
  last_teensy_write.horn = horn;
  last_teensy_write.parking = parking;
  last_teensy_write.autopilot_active = true; //
  teensyPub.publish(last_teensy_write);      //

  for (unsigned int i = 0; i < autonomous_nodes.size(); i++){
    std::string cmd = "gnome-terminal -- rosrun " + autonomous_nodes[i];
    std::cout << "Executing command: " << cmd << std::endl;
    std::system(cmd.c_str());
  }

  std::system("gnome-terminal -e 'sh -c \"ROS_NAMESPACE=usb_cam rosrun image_proc image_proc\"'");
  std::system("gnome-terminal -e 'rosbag record -a -x \"/usb_cam/image_mono/(.*)|/usb_cam/image_rect/(.*)|/usb_cam/image_raw(.*)|/usb_cam/image_color(.*)|/usb_cam/image_proc_debayer(.*)|/usb_cam/image_mono(.*)|/b_cam/image_rect|/usb_cam/image_rect_color|/usb_cam/image_rect_color/theora|/usb_cam/image_proc(.*)|/usb_cam/image_rect|/image_view(.*)\"'");

}

void stopAutopilot() {
  ros::V_string running_nodes;

  if (ros::master::getNodes(running_nodes)) {

    for (unsigned int i = 0; i < running_nodes.size(); i++) {
      // Check if in whitelist
      bool in_whitelist = false;
      for (unsigned int j = 0; j < node_whitelist.size(); j++) {
        if (node_whitelist[j].back() == '*') {
          // It's a wildcard
          size_t l = node_whitelist[j].size() - 1;
          // Cut node to same length and compare
          if (running_nodes[i].substr(0, l) == node_whitelist[j].substr(0, l)) {
            in_whitelist = true;
            break;
          }
        } else {
          if (running_nodes[i] == node_whitelist[j]) {
            in_whitelist = true;
            break;
          }
        }

      }

      if (!in_whitelist) {
        // KILL!
        // Doesn't seem like there is a roscpp function for this
        std::system(("rosnode kill " + running_nodes[i]).c_str());
      }

    }

  }

}

int main(int argc, char *argv[]) {
  ros::init(argc, argv, "dynamo_helper_node");
  std::string command;
  sound = -1;

  ros::NodeHandle nh;
  ros::Subscriber speakSub = nh.subscribe("speak", 10, speakCallback);
  ros::Subscriber teensyReadSub = nh.subscribe("teensy_read", 1, teensyReadCallback);
  ros::Subscriber teensyWriteSub = nh.subscribe("teensy_write", 1, teensyWriteCallback);

  ROS_INFO("Starting dynamo helper node");

  teensyPub = nh.advertise<dynamo_msgs::TeensyWrite>("/teensy_write", 100); //Temporary for driving w/o motor node
  ros::Rate rate(DYNAMO_HELPER_RATE);

  lastTeensyTime = ros::Time::now();
  lastTeensyRebootTime = ros::Time::now();

  lastLowPowerSpeakTime = ros::Time::now();



  while (ros::ok()) {
    ros::spinOnce();

    checkNodeStates();

    if (!gotFirstTeensyMessage) {
      ROS_INFO_THROTTLE(1, "Waiting for first teensy message...");
    } else if ((ros::Time::now() - lastTeensyTime).toSec() > TEENSY_TIMEOUT_TIME) {
      ROS_WARN_THROTTLE(1, "Teensy stopped publishing!");
      std::system("espeak \"Problem with teensy\"");

    } else if (!emergencyButton) {
      ROS_WARN_THROTTLE(1, "Emergency button pressed!");
      stopAutopilot();

    } else if (!autopilot && batteryLowpass.value() < BATTERY_VOLTAGE_THRESHOLD && (ros::Time::now() - lastLowPowerSpeakTime).toSec() > BATTERY_VOLTAGE_LOW_MESSAGE_PERIOD) {
      // Don't say anything about battery while running autopilot. Only every 15 seconds.
      ROS_WARN("Battery voltage low: %.2f V", batteryLowpass.value());
      std::system("espeak \"Battery voltage low\"");

    } else if (autopilot != lastAutopilot) {
      ROS_DEBUG("Got new autopilot state from teensy: %s", autopilot ? "true" : "false");
      if (autopilot) {
        startAutopilot();
        ROS_INFO("Autopilot activated!");

        autopilotActive = true;

      } else {
        stopAutopilot();
        ROS_INFO("Autopilot deactivated!");
        autopilotActive = false;
      }

      lastAutopilot = autopilot;
    } else if (autopilot) { // Constantly tell the teensy that we in fact are on autopilot
      last_teensy_write.header.stamp = ros::Time::now();
      last_teensy_write.header.frame_id = "dynamo_helper_node";
      teensyPub.publish(last_teensy_write);

    } else if (autopilotActive != lastAutopilotActive) {
      if (autopilotActive) {
        // Node is sending autopilot active, play sound
        std::system("paplay /home/dynamo/Music/Rhodes.ogg.ogg");
        std::system("espeak \"Autopilot activated\"");

      } else {
        // autopilot active is set to false when stopping by button or emergency button
        std::system("paplay /home/dynamo/Music/airbus_autopilot.ogg");

      }

      lastAutopilotActive = autopilotActive;
    } else if (parking != lastParking && parking) {
      // Beginning to park
      std::system("espeak \"Parking spot detected\"");

      lastParking = parking;

    } else if (brake != lastBrake && brake) {
      std::system("espeak \"Braking\"");

      lastBrake = brake;

    } else {
      // Play sound
      switch (sound) {
      case -1:
        break;
      case 0:
        command = "espeak \"" + message + "\"";
        break;
      case 1:
        command = "paplay /home/dynamo/Music/KDE_Startup_1.ogg";
        break;
      case 2:
        command = "paplay /home/dynamo/Music/airbus_autopilot.ogg";
        break;
      case 3:
        command = "paplay /home/dynamo/Music/Rhodes.ogg";
        break;

      }
      if (sound != -1) {
        ROS_INFO_STREAM("Executing command: " << command);
        system(command.c_str());
        sound = -1;
      }
    }

    rate.sleep();
  }
  std::exit(EXIT_SUCCESS);
}
