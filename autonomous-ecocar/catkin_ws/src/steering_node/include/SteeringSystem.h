/*
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

Author: Thomas Passer Jensen (s134234@student.dtu.dk)
*/

#ifndef STEERING_SYSTEM_H
#define STEERING_SYSTEM_H

#include <ros/ros.h>
#include <phidget21.h>

#include "LowPass.h"
#include "FilteredDerivative.h"
#include "CUSUM.h"

#include <boost/filesystem.hpp>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/ini_parser.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>
#include <boost/date_time/posix_time/posix_time_io.hpp>

#include <fstream>

#define LOGGING 1

#define TEENSY_NODE_TIMEOUT 1.0 // seconds

// Potentiometer
#define POTENTIOMETER_MIN 50 // only zero if not connected
#define POTENTIOMETER_MAX 1024

// Stepper motor constants
#define STEERING_PHIDGET_SERIAL 418630
#define WAIT_FOR_ATTACH_TIMEOUT 5000   // [ms]

#define MAX_CURRENT 2.8 //
#define TARGET_ACCELERATION 100000  // 16ths of a step/s2
#define TARGET_VELOCITY 15000   // 16ths of a step/s
#define MAX_VELOCITY 16000 // Definite cap when using VELOCITY_INCREASE_COEFFICIENT

#define CALIBRATION_ACCELERATION 100000
#define CALIBRATION_VELOCITY 2000

// Adaptive steering velocity constants
#define INCREASE_VELOCITY_THRESHOLD 0.5 // Don't increase steering velocity for vehicle velocities below this, m/s
#define VELOCITY_INCREASE_COEFFICIENT 4 // mm/s on rack per m/s of car

// Steering geometry constants (all in mm)
#define WIDTH 921.78 // Distance between wheel turning axes
#define RACK_LENGTH 615 // Length of rack (+ extensions)
#define OFFSET 92.65 // Perpendicular distance between wheel axis and rack
#define TIE_ROD_LENGTH 150
#define STEERING_ARM_LENGTH 125

#define PINION_RADIUS 25.6 //TODO check value

#define POT_TO_DISPLACEMENT 0.093705
#define STEPPER_STEPS_PER_REVOLUTION (200.0*(15.0+3.0/10.0)*16.0) // 1.8 deg, 15+3/10 gearing and 16 microstepping
#define K_UNIT (STEPPER_STEPS_PER_REVOLUTION)/(2*M_PI*PINION_RADIUS)

#define LOW_PASS_TIME_CONSTANT 0.1

enum ControllerState {
    STATE_INIT,
    STATE_MISSING_CALIBRATION,
    STATE_CALIBRATING_LIMITS,
    STATE_CALIBRATING_VELOCITY,
    STATE_OK,
    STATE_NO_FEEDBACK,
    STATE_ERROR
};

enum CalibrationState {
  GOING_LEFT,
  GOING_RIGHT
};

class SteeringSystem{
  public:
    SteeringSystem(double frequency);
    void setReference(double angle);
    void setEngaged(bool engaged);
    void updateMeasurements(double encoderCount, double potValue);
    void updateVehicleVelocity(double vel);
    void loop();
    void startCalibration();
    void startVelocityCalibration();
    void sanityCheck();
    void close();
    double getLeftAngle();
    double getRightAngle();
    double getSteeringSpeed();
    bool isSkipping();
    bool isSlipping();

  private:
    void calibrate();
    void calibrateVelocity();
    void diagnose();
    void saveConfig();
    bool loadConfig();
    void initStepper();
    bool checkPotentiometerValue(double value);

    // Stepper
    CPhidgetStepperHandle steeringStepper;
    long long int currentStepPosition;
    long long int lastStepPosition;
    unsigned int stepperVelocity;
    unsigned int currentStepperVelocity;

    // Encoder
    double encoderCount; // should be integers
    double lastEncoderValue;
    double countZero;

    // potentiometer
    double potReference;
    double potValue;
    double potZero;
    double potMin;
    double potMax;
    LowPass<double> potLowpass;

    // Controller logic
    ControllerState controllerState;
    CalibrationState calibrationState;
    bool engaged;
    bool moving;
    bool hasCalibration;
    bool gotMeasurements;

    // Controller parameters
    double angleReference;
    double leftAngle;
    double rightAngle;
    ros::Time lastTeensyTime;

    // Diagnosis system
    bool diagInit;
    FilteredDerivative r1, r2;
    CUSUM g1, g2;
    bool motorSkipping, gearSlipping;

    // Logging
    std::ofstream logfile;

    // Limit calibration
    ros::Time startTurnTime;

    // Velocity calibration
    unsigned int timesWithoutSlip;

    // Adaptive steering speed variables
    double vehicleVelocity;
    double stepsToAngleSpeedCoefficient;

    // Functions to convert between sensor values
    double displacementToPot(double x);
    double potToDisplacement(double pot);

    // Steering geometry calculations
    double thetaZero;
    double calcLeftAngle(double x);
    double calcRightAngle(double x);
    double calcDisplacement(double referenceAngle);
    double calcDisplacementLeft(double leftAngle);
    double calcDisplacementRight(double rightAngle);
};

#endif
